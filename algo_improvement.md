Одним из главных недостатков данного алгоритма по мнению авторов являлся большой объём используемой памяти. Больше всего пространства занимала приоритетная очередь Q, ведь в ней одновременно мог храниться большой массив данных. 

Так, оптимизация хранения данных в приоритетной очереди, могла бы серьёзно улучшить алгоритм.



Простым, но эффективным решением является хранение множеств в очереди в виде битового массива, используя стандартную библиотеку bitset. 

Введём класс BitSet, с помощью которого будем представлять можества в виде 32 - битных массивов, где каждый бит будет отвечать за наличие или отсутсвие вершины в очереди.

В данной программе была приведена реализация для массива, размер которого задаётся заранее, но можно было сделать размер динамическим, представив его как вектор из однобитовых чисел типа bool. Однако в таком случае нам пришлось бы хранить дополнительную информацию, такую, например, как размер вектора, а так как битовые массивы в нашем случае используются небольшие, и они сами по себе сопоставимы по размеру с числом типа int, добавление даже пары чисел на вектор сделало бы общий объём информации больше в несколько раз.



Так выглядит класс BitSet и компаратор BitSetCompare:

```cpp
class BitSet {
private:
    bitset<SIZE> bits;
public:
    BitSet(const std::set<int>& set) {
        for (int elem : set) {
            if (elem >= 0 && elem < SIZE) {
                bits.set(elem);
            }
        }
    }


    bool test(int pos) const {
        return bits.test(pos);
    }

    // Вывод множества
    void print() const {
        for (int i = 0; i < SIZE; ++i) {
            if (bits[i]) {
                std::cout << i << " ";
            }
        }
        std::cout << std::endl;
    }


    // Функция, возвращающая множество (set) из битсета
    std::set<int> toSet() const {
        std::set<int> resultSet;
        for (int i = 0; i < SIZE; ++i) {
            if (bits[i]) {
                resultSet.insert(i);
            }
        }
        return resultSet;
    }
};


struct BitSetCompare {
    bool operator()(const BitSet& a, const BitSet& b) const {
        for (int i = 0; i < SIZE; ++i) {
            if (a.test(i) != b.test(i)) {
                return a.test(i) < b.test(i);
            }
        }
        return false; // Если все биты равны, считаем множества равными
    }
};
```



И очередь будет иметь вид

```cpp
using PriorityQueue = priority_queue<BitSet, vector<BitSet>, BitSetCompare>;
```



В остальном реализация алгоритма осталась почти такая же, только добавились операции перевода массива в множество и наоборот. Весь изменённый алгоритм можно айти в репозитории под названием algo_bit.cpp.



#### Сравнение занимаемой памяти оригинального и улучшенного алгоритма



Так как очередь -- сложная структура, подсчитать её точный размер часто бывает невозможной задачей. Однако этот размер можно подсчитать примерно, основываясь на знаниях о её внутреннем устройстве.

Идея подсчёта размера такова: для каждого сгенерированного графа (генерация идёт по тому же принципу, что и при тестировании задержки) будем считать максимальный размер очереди. Далее будем подсчитывать размер, который она занимает, основываясь на таких предположениях о её реализации:

1)В случае, когда Q -- очередь из множеств.

Каждое множество может иметь разный размер и, следовательно, занимать разное количество памяти, std::set обычно использует красно-черные деревья для хранения элементов, что вносит дополнительные накладные расходы, связанные с структурой дерева.

В красно-черных деревьях каждый элемент хранится в узле дерева, который, помимо самого значения, содержит указатели на родительский элемент, два потомка и, возможно, информацию о цвете узла (для красно-черных деревьев).

Чтобы оценить общий размер, можно посчитать размер всех множеств в очереди, учитывая размер каждого множества и приблизительный размер каждого узла дерева, который используется внутри множества. 

```cpp
size_t estimatedSetNodeSize = sizeof(set<int>::value_type) + sizeof(void*) * 3; 
maxSize = MaxNodeN * estimatedSetNodeSize + sizeof(Q);
```



2) В случае, когда Q -- очередь из битовых массивов, размер высчитывается проще.

```Cpp
 maxelems * SIZE + sizeof(Q)
```



Теестирование программы дало следующие результаты: (график также построен в Python с помощью библиотеки matplotlib)



<img src="/Users/mika/Library/Containers/bluestone/Data/Library/Application%20Support/bluestone/assets/JQSyhLM3aqdCJ.png" alt="" height="348"/>

<img src="/Users/mika/Library/Containers/bluestone/Data/Library/Application%20Support/bluestone/assets/m3WFFYJCIyagD.png" alt="" height="341"/>



Видим, что в случае битового массива памяти было затрачено в десятки раз меньше: большинство точек расположилось до значения в 250 байтов, а в случае очереди множеств  счёт идёт на тысячи.



Таким образом, такой способ представления данных очень удобен: он не меняет временную оценку выполнения задачи, так как операции перевода множества в массив и наоборот линейны, но объём используемой памяти значительно уменьшается, что очень существенно на больших графах.
# Описание кода на С++, реализующего алгоритм из статьи

## Выбор структур данных из стандартной библиотеки STL

Для решения задчи мною были выбраны следующие шаблоны:

```cpp
struct LexCompare {
    bool operator() (const set<int>& a, const set<int>& b) const {
        return lexicographical_compare(b.begin(), b.end(), a.begin(), a.end());
    }
};

using Graph =  vector<set<int> >;
using MISet = set<int>;
using PriorityQueue = priority_queue<MISet, vector<MISet>, LexCompare>;
using SetOfSets = std::set<std::set<int> >;
```

Для представления графа было решено использовать список смежности, так как важной частью алгоритма является подсчёт лексикографически первого МНМ. В случае, если бы граф был представлен матрицей смежности, данная функция заняла бы квадратичное время, так как для выяснения соседства необходимо было бы проходиться по каждому элементу матрицы.

Приоритетная очередь хранит элементы типа MISet. Приоритет элементов в очереди управляется с помощью структуры LexCompare. Она служит компаратором, определяющим порядок элементов в очереди. PriorityQueue в C++ по умолчанию является максимальной кучей, где элемент с наивысшим приоритетом (в нашем случае, лексикографически наименьший) находится на вершине.



Кроме этого, для проверки выводящегося множества на уникальность, была структура "множества множеств", SetOfSets в которую добавлялись все множества , вставленные  приоритетную очередь, Важно отметить, что проверки на уникальность не проводились в оригинальном алгоритме, так что это является некой модификацией.

## Описание используемых функций

#### Вывод множества

```cpp
void Print_MISet(const MISet& set_inp){
    for (int vertex : set_inp) {
        cout << vertex << " ";
    }
    cout << endl;
}
```

Данная функция проходится по всем элементам множества и выводит каждый через пробел. Её вычислительная сложность -- `O(n)`. Аналогично устроена функция Print_MISetToFile.



#### Проверка на принадлежность

```cpp
inline bool IsIn(const set<int>&set_inp, int v_inp){
    return set_inp.find(v_inp) != set_inp.end();
}
```

В C++, множества реализованы как сбалансированное бинарное дерево поиска. Поиск в таком дереве имеет временную сложность `O(log n)`.



#### Проверка на максимальность множества

```cpp
bool IsMaximal(const set<int>&set_inp, const vector<set<int> >&graph_inp, int j){
    vector<bool> adjVec(j + 1, false);
    for (int v: set_inp) {
        if (v <= j ) {
            adjVec[v] = true; // Отметили вершину из Stmp
            for (int u: graph_inp[v]) {
                if (u <= j) adjVec[u] = true; // Отметили смежные вершины
            }
        }
    }
    for (int i = 0; i <= j; ++i) {
        if (!adjVec[i]) return false;
    }
    return true;
}
```

Эта функция проверяет, является ли полученное независимое множество максимальным в графе, который является подграфом до j-й вершины заданного.

Строится вектор смежности adjVec из j + 1 вершины, в котором заведомо отмечается вершина из данного множества и все смежные ей вершины. Вектор используется для отметки вершин, которые уже учтены в множестве или смежны с ним. После этого цикла функция снова проходит по каждому элементу вектора и возвращает false, если встречает хотя бы неотмеченную вершину.  Главная идея заключается в том, что если все вершины до j включительно отмечены, это означает, что не существует вершины, которую можно было бы добавить к множеству без нарушения независимости.

Рассчитаем временную сложность этого алгоритма. Вектор adjVec инициализируется за O(j + 1). Алгоритм проходит по каждой вершине множества один раз и далее по одному разу по каждой соседней с ней вершине. Это означает, что каждое ребро, инцидентное вершине из множества, будет рассмотрено один раз. Это не должно превышать O(n + m) в худшем случае. В конце алгоритм проходит по каждому элементу вектора один раз,что снова занимает О(j + 1).

В итоге, временная сложность функции равна O(2j +  2 + n + m) ~ O(j + n + m) ~ `O(n + m)`.

#### Ограничение множества первыми j вершинами

```cpp
MISet FirstJVertices (const MISet &set_inp, int j){
    MISet Sj;
    for (int elem : set_inp) {
        if (elem <= j) {
            Sj.insert(elem);
        }
        else break;
    }
    return Sj;
}
```

Эта функция осуществляет пересечение S и вершин {0,...,j}. Её сложность в худшем случае -- `O(n log n)`.



#### Поиск лексикографически первого МНМ (в частности, содержащего в себя заданное множество)

```cpp
MISet FindFirstMIS(const Graph& G, int n, MISet set_inp) {
    vector<bool> availability_status(n, true);

    for (int init_vertex : set_inp) {
        availabilityVec[init_vertex] = false;  // Сама вершина
        for (int neighbour : G[init_vertex]) {
            availabilityVec[neighbour] = false;  // Соседи
        }
    }
    for (int i = 0; i < n; ++i) {
        if (availabilityVec[i]) {
            set_inp.insert(i);
            for (int neighbour: G[i]) {
                availabilityVec[neighbour] = false;
            }
        }
    }
    return set_inp;
}
```

Данная функция выполняет две роли -- она может как просто находить лексикографически первое МНМ графа, что необходимо при поиске S*, так и лекс. первое МНМ, содеращее нужное нам подмножество, что мы используем при поиске Т. В первом случае в качестве set_inp просто должно подаваться пустое множество.

Схема работы функции следующая: создаётся локальный объект -- вектор availabilityVec из  доступных к добавлению вершин.

В начале цикл проводится по вершинам переданного (по значению) множества set_inp. Каждая вершина отмечается в векторе как недоступная, недоступными же помечаются и все её соседи.

Второй цикл проходится по всем вершинам графа. Он проверяет, не смежна ли эта вершина с какой-то ранее добавленной и в случае отрицательного ответа вставляет её в res и вычёркивает из списка доступности все смежные с ней вершины.

В сущности, эта функция просто является реализацией алгоритма, представленного в статье. Её временная сложность такова: инициацлизация вектора займёт O(n), а циклы будут работать со сложнностью O(n + m) каждый, поскольку каждая вершина и каждое ребро рассматриваются один раз. Таким образом, общая сложность функции равна `O(n + m)`.



### Описание main

Функция main начинается с считывания графа из файла input.txt. Предполагается формат ввода: <общее число вершина в графе> <рёбра графа, представленные парами вершин>. Программа обрабатывает некоторые простейшие ошибки: ошибку открытия файла, пустой файл, выход вершины за границы диапазона, нечётное число вершин. После этого открывается и очищается (или создаётся новый) файл output.txt для вывода результата работы алгоритма. 

Далее создаются два множества: S и S_first (≡ S*, то есть лекс. первое МНМ).  Создаётся очередь Q, в неё добаваляется S_first.

Начинается цикл, который будет выполняться, пока очередь Q не опустеет. В нём, аналогично алгоритму из статьи, в качестве S выбирается элемент Q с максимальным приоритетом, он выводится в файл и удаляется из очереди.

После начинается цикл по всем j. Если j оказывается смежным с какой-либо вершиной i < j, создаётся Sj (пересечение S со всеми вершинами до j) и Stmp (≡  Sj - Г(j) **∪** {j}). Если Stmp -- МНМ подграфа, состоящего из вершин до j, то находится Т -- лекс. первое МНМ G, содержащее Stmp и Т вставляется в очередь.



### Временная оценка



```cpp
for (int neighbour : G[j]) { //перебираем н из соседей j
    if (IsIn(S, neighbour) && neighbour < j) {flag = true; break;}
```

Функция IsIn была оценена нами в O(log n), цикл может быть повторён не более n раз, то есть весь цикл займёт `O(n log n)`.



```cpp
MISet Sj = FirstJVertices(S, j), Sjtmp;
```

`O(n log n)`.



```cpp
set_difference(Sj.begin(), Sj.end(), G[j].begin(), G[j].end(), inserter(Sjtmp, Sjtmp.begin()));
```

Время исполнения библиотечной функции set_difference оценивается как `O(n)`



```cpp
Sjtmp.insert(j);
```

Вставка в множество занимает `O(log n)`.



```cpp
if (IsMaximal(Sjtmp, G, j)) {
    MISet T = FindFirstMIS(G, numVertices, Sjtmp);
    Q.push(T);
}
```

Проверка на максимальность займёт O(n + m), нахождение лекс. первого МНМ тоже, а вставка в очередь O(log n), из чего следует, что общая оценка времени исполнения = `O(n +m + log n)`.



Эти вычисления будут повторятся не более n раз перед выводом следующего МНМ, а, значит, задержу можно оценить как O(n(log n + n + m + n log n)) ~ O(nm) ~ `O(n^3)`.# MIS_project
